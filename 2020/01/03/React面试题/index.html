<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="React面试题"><meta name="keywords" content=""><meta name="author" content="Wayxuan,undefined"><meta name="copyright" content="Wayxuan"><title>React面试题【仙女璇】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是虚拟-DOM？"><span class="toc-number">1.</span> <span class="toc-text">什么是虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么虚拟-DOM-会提高性能？"><span class="toc-number">2.</span> <span class="toc-text">为什么虚拟 DOM 会提高性能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-diff-原理？"><span class="toc-number">3.</span> <span class="toc-text">react diff 原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-构建组件的三种方式？"><span class="toc-number">4.</span> <span class="toc-text">react 构建组件的三种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何-React-createElement？"><span class="toc-number">5.</span> <span class="toc-text">如何 React.createElement？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类组件（Class）和函数组件（Function）有什么区别？"><span class="toc-number">6.</span> <span class="toc-text">类组件（Class）和函数组件（Function）有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是纯函数？"><span class="toc-number">7.</span> <span class="toc-text">什么是纯函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件的-状态（State）和属性（props）之间有何不同？"><span class="toc-number">8.</span> <span class="toc-text">(组件的)状态（State）和属性（props）之间有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在构造函数中，调用-super-props-的目的-作用是什么？"><span class="toc-number">9.</span> <span class="toc-text">在构造函数中，调用 super(props)的目的/作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么类方法需要绑定到类实例？"><span class="toc-number">10.</span> <span class="toc-text">为什么类方法需要绑定到类实例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有几种为事件处理函数绑定-this-指向方法？"><span class="toc-number">11.</span> <span class="toc-text">有几种为事件处理函数绑定 this 指向方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有几种常用方法可以避免在-react-中绑定方法？"><span class="toc-number">12.</span> <span class="toc-text">有几种常用方法可以避免在 react 中绑定方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是受控组件？"><span class="toc-number">13.</span> <span class="toc-text">什么是受控组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#受控组件和非受控组件区别是什么？"><span class="toc-number">14.</span> <span class="toc-text">受控组件和非受控组件区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-React-Hooks？"><span class="toc-number">15.</span> <span class="toc-text">什么是 React Hooks？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-React-Hooks-好处是啥？"><span class="toc-number">16.</span> <span class="toc-text">使用 React Hooks 好处是啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-useState，useEffect？"><span class="toc-number">17.</span> <span class="toc-text">什么是 useState，useEffect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-会取代-render-props-和高阶组件吗？"><span class="toc-number">18.</span> <span class="toc-text">Hooks 会取代 render props 和高阶组件吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#这三个点（…）在-React-是干嘛用的？"><span class="toc-number">19.</span> <span class="toc-text">这三个点（…）在 React 是干嘛用的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？"><span class="toc-number">20.</span> <span class="toc-text">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不直接更新-state-呢？"><span class="toc-number">21.</span> <span class="toc-text">为什么不直接更新 state 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当调用-setState-时，React-render-是如何工作的？"><span class="toc-number">22.</span> <span class="toc-text">当调用 setState 时，React render 是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-setState-之后发生了什么？"><span class="toc-number">23.</span> <span class="toc-text">调用 setState 之后发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果需要根据以前的状态重新设置状态，怎么写比较好？"><span class="toc-number">24.</span> <span class="toc-text">如果需要根据以前的状态重新设置状态，怎么写比较好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-中-refs-是干嘛用的？"><span class="toc-number">25.</span> <span class="toc-text">react 中 refs 是干嘛用的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-中-keys-是什么作用？"><span class="toc-number">26.</span> <span class="toc-text">react 中 keys 是什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-组件生命周期有哪些不同阶段？"><span class="toc-number">27.</span> <span class="toc-text">React 组件生命周期有哪些不同阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-组件生命周期方法有哪些？"><span class="toc-number">28.</span> <span class="toc-text">React 组件生命周期方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldComponentUpdate-是做什么的，-react-性能优化是哪个周期函数？"><span class="toc-number">29.</span> <span class="toc-text">shouldComponentUpdate 是做什么的，(react 性能优化是哪个周期函数？)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应该在-React-组件的何处发起-ajax-请求"><span class="toc-number">30.</span> <span class="toc-text">应该在 React 组件的何处发起 ajax 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述事件在-React-中的处理方式，-在-react-中如何处理事件-？"><span class="toc-number">31.</span> <span class="toc-text">描述事件在 React 中的处理方式，(在 react 中如何处理事件)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-组件的划分业务组件技术组件？"><span class="toc-number">32.</span> <span class="toc-text">React 组件的划分业务组件技术组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？"><span class="toc-number">33.</span> <span class="toc-text">展示组件(Presentational component)和容器组件(Container component)之间有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述-Flux-与-MVC？"><span class="toc-number">34.</span> <span class="toc-text">描述 Flux 与 MVC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简述-Flux-思想？"><span class="toc-number">35.</span> <span class="toc-text">简述 Flux 思想？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是高阶组件-Higher-Order-Component-？"><span class="toc-number">36.</span> <span class="toc-text">什么是高阶组件(Higher Order Component)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解-redux-么，说一下-redux-吧？"><span class="toc-number">37.</span> <span class="toc-text">了解 redux 么，说一下 redux 吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-有什么缺点？"><span class="toc-number">38.</span> <span class="toc-text">redux 有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-中的-StrictMode-严格模式-是什么？"><span class="toc-number">39.</span> <span class="toc-text">React 中的 StrictMode(严格模式)是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-prop-drilling，如何避免？"><span class="toc-number">40.</span> <span class="toc-text">什么是 prop drilling，如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-React-Context？"><span class="toc-number">41.</span> <span class="toc-text">什么是 React Context？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何避免组件的重新渲染？"><span class="toc-number">42.</span> <span class="toc-text">如何避免组件的重新渲染？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-React-Fiber？"><span class="toc-number">43.</span> <span class="toc-text">什么是 React Fiber？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在-React-中使用构造函数和-getInitialState-有什么区别？"><span class="toc-number">44.</span> <span class="toc-text">在 React 中使用构造函数和 getInitialState 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何有条件地向-React-组件添加属性？"><span class="toc-number">45.</span> <span class="toc-text">如何有条件地向 React 组件添加属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createElement和cloneElement有什么区别？"><span class="toc-number">46.</span> <span class="toc-text">createElement和cloneElement有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React项目用过什么脚手架？"><span class="toc-number">47.</span> <span class="toc-text">React项目用过什么脚手架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#没想好题目-自定义属性-？"><span class="toc-number">48.</span> <span class="toc-text">没想好题目..自定义属性.？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Wayxuan</div><div class="author-info-description">普通小孩热爱生活中</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Wayxuan" target="_blank">GitHub<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="Mailto:wyx97321@outlook.com" target="_blank">E-Mail<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1766552895&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">2</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">1</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">仙女璇</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">React面试题</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-01-03 | 更新于 2020-01-03</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"></div></div></div><div class="main-content"><p>翻到OneNote乱七八糟的面试题截图，随手整理一下整了一天，手已软··· 还有好多怎么办呀！</p>
<hr>
<blockquote>
<h3 id="什么是虚拟-DOM？"><a href="#什么是虚拟-DOM？" class="headerlink" title="什么是虚拟 DOM？"></a><font color=pink ><b>什么是虚拟 DOM？</b></font></h3></blockquote>
<ul>
<li>虚拟 DOM（<b>VDOM</b>）是真实 DOM 在内存中的表示，是 UI 的表示形式，同时和实际 DOM 同步。这是发生在<b>渲染函数被调用</b>和<b>DOM 元素在屏幕上显示</b>之间的过程,整个过程被称为<b>调和</b>。</li>
</ul>
<a id="more"></a>

<blockquote>
<h3 id="为什么虚拟-DOM-会提高性能？"><a href="#为什么虚拟-DOM-会提高性能？" class="headerlink" title="为什么虚拟 DOM 会提高性能？"></a><font color=pink ><b>为什么虚拟 DOM 会提高性能？</b></font></h3></blockquote>
<ul>
<li><p>虚拟 DOM 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
</li>
<li><p>用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中，当状态变更的时候，重新构造一颗新的对象树，然后用新的树和旧的树进行比较，记录两棵树的差异，把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
</li>
</ul>
<blockquote>
<h3 id="react-diff-原理？"><a href="#react-diff-原理？" class="headerlink" title="react diff 原理？"></a><font color=pink ><b>react diff 原理？</b></font></h3></blockquote>
<ol>
<li>把树形结构按层分解，只比较同级元素。</li>
<li>把列表结构的每个单元添加唯一的 key 属性，方便比较。</li>
<li>react 只会匹配相同的 class 名的 component。</li>
<li>合并操作，调用 component 的 setState 方法的时候，react 将其标记到 dirty。到每一个事件循环结束，react 检查所有标记 dirty 的 component 重新绘制。</li>
<li>选择性子树渲染，开发人员可以重写 shouldComponentUpdate，提高 diff 性能。</li>
</ol>
<blockquote>
<h3 id="react-构建组件的三种方式？"><a href="#react-构建组件的三种方式？" class="headerlink" title="react 构建组件的三种方式？"></a><font color=pink ><b>react 构建组件的三种方式？</b></font></h3></blockquote>
<ol>
<li>React.createClass()</li>
<li>ES6 clss</li>
<li>无状态函数 function</li>
</ol>
<blockquote>
<h3 id="如何-React-createElement？"><a href="#如何-React-createElement？" class="headerlink" title="如何 React.createElement？"></a><font color=pink ><b>如何 React.createElement？</b></font></h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const element=React.createElement(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'h1'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#123;className:<span class="string">'greeting'</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'Hello,world!'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="类组件（Class）和函数组件（Function）有什么区别？"><a href="#类组件（Class）和函数组件（Function）有什么区别？" class="headerlink" title="类组件（Class）和函数组件（Function）有什么区别？"></a><font color=pink ><b>类组件（Class）和函数组件（Function）有什么区别？</b></font></h3></blockquote>
<ol>
<li><b>类组件</b>允许使用其它特性，如组件自身的状态 state 和生命周期钩子，还能使组件直接访问 store 并维持状态。</li>
<li><b>当组件只接收 props 组件渲染页面时，就是一个”无状态组件(Stateless)”</b>,可以使用一个纯函数来创建这样的组件，这就是<b>函数组件</b>，这种组件也被称为”哑组件(Dumb)”或”展示组件”。</li>
<li>通过 function 定义组件的写法更加 js，代码结构简单，代码量小，没有 this 指向问题</li>
</ol>
<blockquote>
<h3 id="什么是纯函数？"><a href="#什么是纯函数？" class="headerlink" title="什么是纯函数？"></a><font color=pink ><b>什么是纯函数？</b></font></h3></blockquote>
<ul>
<li>纯函数<b>是不依赖并且不会在其作用域之外修改变量状态的函数</b>。本质上，纯函数<b>始终</b>在给<b>定向同参数</b>的情况下<b>返回相同的结果</b>。</li>
</ul>
<blockquote>
<h3 id="组件的-状态（State）和属性（props）之间有何不同？"><a href="#组件的-状态（State）和属性（props）之间有何不同？" class="headerlink" title="(组件的)状态（State）和属性（props）之间有何不同？"></a><font color=pink ><b>(组件的)状态（State）和属性（props）之间有何不同</b>？</font></h3></blockquote>
<ol>
<li>State 是一个数据结构，用于组件挂载时所需数据的默认值，是组件自己管理数据，控制自己的状态，可变。</li>
<li>Props(properties)是组件的配置，是外部传入的数据参数，Props 由父组件传递给子组件，并且就子组件而言，props 是不可变的。组件虽然不能改变自身的 props，但是可以把其子组件的 props 放在一起统一管理。Props 也不仅仅是数据，回调函数也可以通过 Props 传递。</li>
</ol>
<ul>
<li>props 和 state 是普通的 JS 对象，它们都包含影响渲染输出的信息，<b>没有 state 的叫做无状态组件，有 state 的叫做有状态组件，多用 props，少用 state，也就是多写无状态组件</b>。</li>
</ul>
<blockquote>
<h3 id="在构造函数中，调用-super-props-的目的-作用是什么？"><a href="#在构造函数中，调用-super-props-的目的-作用是什么？" class="headerlink" title="在构造函数中，调用 super(props)的目的/作用是什么？"></a><font color=pink ><b>在构造函数中，调用 super(props)的目的/作用是什么？</b></font></h3></blockquote>
<ul>
<li>在 super()被调用之前，子类构造函数是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()，ES6 一样。</li>
<li>将参数 props 传递 给 super()的原因则是：便于在子类中能在 constructor 访问 this.props，通过 this.props 来获取传入的 props。</li>
</ul>
<blockquote>
<h3 id="为什么类方法需要绑定到类实例？"><a href="#为什么类方法需要绑定到类实例？" class="headerlink" title="为什么类方法需要绑定到类实例？"></a><font color=pink ><b>为什么类方法需要绑定到类实例？</b></font></h3></blockquote>
<ul>
<li>在 JS 中，this 值会根据当前上下文变化，在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此非常有必要把这些方法绑定到实例，通常这是在构造函数中完成的。</li>
</ul>
<blockquote>
<h3 id="有几种为事件处理函数绑定-this-指向方法？"><a href="#有几种为事件处理函数绑定-this-指向方法？" class="headerlink" title="有几种为事件处理函数绑定 this 指向方法？"></a><font color=pink ><b>有几种为事件处理函数绑定 this 指向方法？</b></font></h3></blockquote>
<ol>
<li><b>组件初始化时，通过 class 类的方法在 constructor 里绑定，好处只会执行一次。</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this.state = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">this.keyUpHandle = this.keyUpHandle.bind(this);</span></pre></td></tr></table></figure>

<ol start="2">
<li><b>方法调用时绑定，每一次数据改变，方法重新调用就会执行。</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;input onKeyUp = &#123; this.nickNameKeyUpHandle.bind(this) &#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">nickNameKeyUpHandle(e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.group(<span class="string">"在方法调用的时候绑定"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    console.log(<span class="string">"e.target.value"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(<span class="string">"this"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    console.groupEnd();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="3">
<li><b>render 里，用箭头函数绑定，</b>因为箭头函数的 this 指向箭头函数定义的时候其所处作用域的 this，render 函数 this 始终指向组件实例，所以箭头函数 this 也指向组件实例，但是，<b>每次数据改变页面刷新都会重新绑定。</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;input onKeyUp = &#123; e =&gt; this.skillKeyUpHandle(e) &#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">skillKeyUpHandle(e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.group(<span class="string">"箭头函数改变this指向"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    console.log(<span class="string">"e.target.value"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(<span class="string">"this"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    console.groupEnd();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="有几种常用方法可以避免在-react-中绑定方法？"><a href="#有几种常用方法可以避免在-react-中绑定方法？" class="headerlink" title="有几种常用方法可以避免在 react 中绑定方法？"></a><font color=pink ><b>有几种常用方法可以避免在 react 中绑定方法？</b></font></h3></blockquote>
<ol>
<li><b>将事件处理程序定义为内联箭头函数</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">class SubmitButton extends React.Component&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    constructor(props)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        super(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        this.state=&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            isFormSubmitted:<span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &lt;button onClick=&#123;()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                this.setState(&#123;isFormSubmitted:<span class="literal">true</span>&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;&#125;&gt;Submit&lt;/button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="2">
<li><b>使用箭头函数来定义方法</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">class SubmitButton extends React.Component&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    state=&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        isFormSubmitted:<span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    handleSubmit =()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        this.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            isFormSubmitted:<span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="3">
<li><b>使用带有 Hooks 的函数组件</b></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const SubmitButton=()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    const [isFormSubmitted,setIsFormSubmitted]=useState(<span class="literal">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            setIsFormSubmitted(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;&#125;&gt;Submit&lt;/button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="什么是受控组件？"><a href="#什么是受控组件？" class="headerlink" title="什么是受控组件？"></a><font color=pink ><b>什么是受控组件？</b></font></h3></blockquote>
<ul>
<li>在 HTML 中，类似&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;这样的表单元素会维护自身的状态，并基于用户的输入来更新，当用户提交表单时，前面提到的元素的值将随表单一起被发送，但在 react 中会有些不同,包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。<b>一个输入表单元素，它的值通过 react 这种方式来控制，这样的元素就被称为”受控元素”</b>。</li>
</ul>
<blockquote>
<h3 id="受控组件和非受控组件区别是什么？"><a href="#受控组件和非受控组件区别是什么？" class="headerlink" title="受控组件和非受控组件区别是什么？"></a><font color=pink ><b>受控组件和非受控组件区别是什么？</b></font></h3></blockquote>
<ol>
<li><p><b>受控组件</b>是 react 控制中的组件，并且是表单数据真实的唯一来源。</p>
</li>
<li><p><b>非受控组件</b>是由 DOM 处理表单数据的地方，而不在 react 组件中。</p>
</li>
</ol>
<ul>
<li>尽管非受控组件通常更易于实现，因为只需使用 refs 即可从 DOM 中获取值，但通常建议优先选择受控组件，主要原因是<b>受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式</b>。</li>
</ul>
<blockquote>
<h3 id="什么是-React-Hooks？"><a href="#什么是-React-Hooks？" class="headerlink" title="什么是 React Hooks？"></a><font color=pink ><b>什么是 React Hooks？</b></font></h3></blockquote>
<ul>
<li><b>Hooks</b>是 react16.8 中的新增内容，它们<b>允许在不编写类的情况下使用 state 和其他 react 特性</b>。使用 Hooks 可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks<b>允许咱在不改变组件层次结构的情况下重用有状态逻辑</b>，这使得在许多组件之间或者与社区共享 Hooks 变得很容易。</li>
</ul>
<blockquote>
<h3 id="使用-React-Hooks-好处是啥？"><a href="#使用-React-Hooks-好处是啥？" class="headerlink" title="使用 React Hooks 好处是啥？"></a><font color=pink ><b>使用 React Hooks 好处是啥？</b></font></h3></blockquote>
<ul>
<li><p>首先，Hooks<b>通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担</b>，Hooks<b>可以轻松地操作函数组件的状态，而不需要将它们转换为类组件</b>。</p>
</li>
<li><p><b>Hooks 在类中不起作用</b>，通过使用它们，咱们可以<b>完全避免使用生命周期</b>，例如 componentDidMount、componentDidUpdate、componentWillUnmount，相反去<b>使用像 useEffect 这样的内置钩子</b>。</p>
</li>
<li><p><b>useState、useEffect、useLocation、useParams 等</b>，useLocation 可以获取当前的 url 地址数据，useParams 是路由新增的 hook 方法可以直接获取到当前的 params 参数。</p>
</li>
</ul>
<blockquote>
<h3 id="什么是-useState，useEffect？"><a href="#什么是-useState，useEffect？" class="headerlink" title="什么是 useState，useEffect？"></a><font color=pink ><b>什么是 useState，useEffect？</b></font></h3></blockquote>
<ol>
<li>useState 可以在 function 定义的组件中设置局部状态，返回两个值:局部状态的名字和改变状态的方法。改变数据或者使用数据直接使用 useState，数组。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const &#123;useState&#125;=React;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Counter</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    const [count,setCount]=useState(0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="2">
<li>useEffect 副作用，可以在 function 定义的组件中模拟生命周期，参数一是回调函数，参数二是依赖项，当参数二中的数据改变之后会触发第一个回调函数，如果参数二为空数组表示组件初始化的时候只执行一次</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;,[...])</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="Hooks-会取代-render-props-和高阶组件吗？"><a href="#Hooks-会取代-render-props-和高阶组件吗？" class="headerlink" title="Hooks 会取代 render props 和高阶组件吗？"></a><font color=pink ><b>Hooks 会取代 render props 和高阶组件吗？</b></font></h3></blockquote>
<ul>
<li>通常，<b>render、props 和高阶组件仅渲染一个子组件，React 团队认为，Hooks 是服务此用例的更简单方法。</li>
<li>这两种模式仍然有一席之地</b>(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但<b>在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套</b>。</li>
</ul>
<blockquote>
<h3 id="这三个点（…）在-React-是干嘛用的？"><a href="#这三个点（…）在-React-是干嘛用的？" class="headerlink" title="这三个点（…）在 React 是干嘛用的？"></a><font color=pink ><b>这三个点（…）在 React 是干嘛用的？</b></font></h3></blockquote>
<ul>
<li>对于创建<b>具有现有对象</b>的<b>大多数属性的新对象</b>非常方便，更新 state 经常这么做</li>
</ul>
<blockquote>
<h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？"></a><font color=pink ><b>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</b></font></h3></blockquote>
<ul>
<li><b>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</b>。</li>
</ul>
<blockquote>
<h3 id="为什么不直接更新-state-呢？"><a href="#为什么不直接更新-state-呢？" class="headerlink" title="为什么不直接更新 state 呢？"></a><font color=#0000FF ><b>为什么不直接更新 state 呢？</b></font></h3></blockquote>
<ul>
<li>如果试图<b>直接更新 state，则不会重新渲染组件，需要使用 setState()方法来更新 state</b>，它调度对组件 state 对象的更新，当 state 改变时，组件通过重新渲染来响应。</li>
</ul>
<blockquote>
<h3 id="当调用-setState-时，React-render-是如何工作的？"><a href="#当调用-setState-时，React-render-是如何工作的？" class="headerlink" title="当调用 setState 时，React render 是如何工作的？"></a><font color=pink ><b>当调用 setState 时，React render 是如何工作的？</b></font></h3></blockquote>
<ul>
<li><p>咱们可以将”render”分为两个步骤:</p>
<ol>
<li><p><b>虚拟 DOM 渲染</b>:当 render 方法被调用时，它返回一个新组件的虚拟 DOM 结构，当调用 setState()时，render 会被再次调用，因为默认情况下 shouldComponentUpdate 总是返回 true，所以默认情况下 react 是没有优化的。</p>
</li>
<li><p><b>原生 DOM 渲染</b>:react 只会在虚拟 DOM 中修改真实 DOM 节点，而且修改的次数非常少–这是很棒的 react 特性，它优化了真实 DOM 的变化，使 React 变得更快。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a><font color=pink ><b>调用 setState 之后发生了什么？</b></font></h3></blockquote>
<ul>
<li><p>在代码中调用 setState 函数之后，react 会<b>将</b>传入的参数对象和组件当前的<b>状态合并</b>，然后<b>触发所谓的调和过程</b>。</p>
</li>
<li><p>经过调和过程，react 会以相对高效的方式<b>根据新的状态构建 react 元素树并且着手重新渲染整个 UI 界面</b>。</p>
</li>
<li><p><b>在 react 得到元素树之后，react 会自动计算出新树和老树的节点差异，然后根据差异对界面进行最小化重渲染</b>，在差异计算算法中，react 能够相对精确地知道哪些位置发生了改变，以及应该如何改变，这就<b>保证了按需更新而不是全部重新渲染</b>。</p>
</li>
</ul>
<blockquote>
<h3 id="如果需要根据以前的状态重新设置状态，怎么写比较好？"><a href="#如果需要根据以前的状态重新设置状态，怎么写比较好？" class="headerlink" title="如果需要根据以前的状态重新设置状态，怎么写比较好？"></a><font color=pink ><b>如果需要根据以前的状态重新设置状态，怎么写比较好？</b></font></h3></blockquote>
<ul>
<li>将一个函数传递给 setState，该函数接收上一个 state 的值和当前的 props,并返回一个新的状态。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this.setState((prevState,props)=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">return</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        streak:prevState.streak+props.count</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="react-中-refs-是干嘛用的？"><a href="#react-中-refs-是干嘛用的？" class="headerlink" title="react 中 refs 是干嘛用的？"></a><font color=pink ><b>react 中 refs 是干嘛用的？</b></font></h3></blockquote>
<ul>
<li>Refs<b>提供了一种访问在 render 方法中创建 DOM 节点或者 React 元素的方法</b>，在典型的数据流中，父子组件交互的唯一方式是 props，先要修改子组件，需要使用新的 props 重新渲染，凡是有例外，某些情况下咱们需要在典型数据流外，<b>强制修改子代</b>，这个时候可以使用 refs，<b>在组件添加一个 ref 属性来用</b>，该属性的<b>值</b>是一个<b>回调函数</b>，接收作为其<b>第一个参数的底层 DOM 元素</b>或<b>组件的挂载实例</b>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;form onSumbit=&#123;this.handleSubmit&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> ref=&#123;(input)=&gt;this.input=input&#125; /&gt;</span></pre></td></tr></table></figure>

<ul>
<li>Input 有一个<b>ref 属性</b>，它的<b>值</b>是一个<b>函数</b>，该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSumbmit 内部访问它。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">handelSubmit=()=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    console.log(<span class="string">'Input Value:'</span>,this.input.value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>经常被<b>误解</b>，只有在类组件才能使用 refs，但 refs 也可以通过利用 js 中的闭包和函数组件一起使用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> CustomForm(&#123;handleSumit&#125;)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">let</span> inputElement</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &lt;form onSubmit=&#123;()=&gt;handleSubmit(inputElement.value)&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                ref=&#123;(input)=&gt;inputElement=input&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &lt;button <span class="built_in">type</span>=<span class="string">"submit"</span>&gt;Submit&lt;/button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &lt;/form&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="react-中-keys-是什么作用？"><a href="#react-中-keys-是什么作用？" class="headerlink" title="react 中 keys 是什么作用？"></a><font color=pink ><b>react 中 keys 是什么作用？</b></font></h3></blockquote>
<ul>
<li><b>Keys 是 react 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</b></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        &lt;ul&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &#123;this.state.todoItems.map((&#123;item,key&#125;)=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">return</span> &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &lt;/ur&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>在开发过程中，我们<b>需要保证某个元素的 key 在其同级元素中具有唯一性</b>。</li>
<li><b>在 React Diff 算法中 react 会借助元素的 key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染</b>。</li>
<li><b>React 还需要借助 Key 值来判断元素和本地状态的关联关系</b>，因此，绝不可忽视转换函数中 Key 的重要性。</li>
</ul>
<blockquote>
<h3 id="React-组件生命周期有哪些不同阶段？"><a href="#React-组件生命周期有哪些不同阶段？" class="headerlink" title="React 组件生命周期有哪些不同阶段？"></a><font color=pink ><b>React 组件生命周期有哪些不同阶段？</b></font></h3></blockquote>
<ul>
<li>在组件生命周期有四个不同阶段：</li>
</ul>
<ol>
<li><p>组件<b>初始化阶段，Initialization</b>，该阶段组件<b>设置一些默认属性和初始化状态 state</b>。</p>
</li>
<li><p><b>挂载阶段，Mounting</b>，该阶段<b>三个过程</b>:将要挂载(componentWillMount)-&gt;render 渲染(<b>此阶段 render 执行一次</b>)-&gt;挂载完成(componentDidMount)。</p>
</li>
<li><p><b>更新阶段，Updating</b>，该阶段中，组件以两种方式更新:<b>属性更新和数据更新</b>。发送新的 props 和 state 状态，当组件接收之后会判断组件是否需要更新，更新阶段只有修改了属性或者数据，都会重新渲染。<b>在 render 调用 this.setState 就会死循环</b>。(shouldComponentUpdata,ComponentWillUpdata 和 ComponentDidUpdata)</p>
</li>
<li><p><b>卸载阶段，componentWillUnmount</b>。</p>
</li>
</ol>
<blockquote>
<h3 id="React-组件生命周期方法有哪些？"><a href="#React-组件生命周期方法有哪些？" class="headerlink" title="React 组件生命周期方法有哪些？"></a><font color=pink ><b>React 组件生命周期方法有哪些？</b></font></h3></blockquote>
<ul>
<li>componentWillMount：渲染之前执行，用于<b>根组件的 App 级配置</b></li>
<li>componentDidMount：在第一次渲染之后执行，可以在这里做<b>ajax 请求、dom 的操作和状态更新以及事件监听器</b></li>
<li>componentWillReceiveProps：初始化 render 时不会执行，会在组件接收到新的状态(props)时被触发，一般<b>用于父组件状态更新时子组件的重新渲染</b></li>
<li>shouldComponentUpdata：<b>确定是否更新组件</b>，默认情况下返回 true，如果确定在 state 或 props 更新后组件不需要再重新渲染，返回 false，这是一个<b>提高性能</b>的好方法</li>
<li>ComponentWillUpdata：在 shouldComponentUpdata 返回 true 确定要更新组件之前执行</li>
<li>ComponentDidUpdata：主要用于<b>更新 DOM 以响应 props 或 state 更改</b></li>
<li>componentWillUnmount：用于<b>取消任何的网络请求，或删除与组件关联的所有事件监听器</b></li>
</ul>
<blockquote>
<h3 id="shouldComponentUpdate-是做什么的，-react-性能优化是哪个周期函数？"><a href="#shouldComponentUpdate-是做什么的，-react-性能优化是哪个周期函数？" class="headerlink" title="shouldComponentUpdate 是做什么的，(react 性能优化是哪个周期函数？)"></a><font color=pink ><b>shouldComponentUpdate 是做什么的，(react 性能优化是哪个周期函数？)</b></font></h3></blockquote>
<ul>
<li>shouldComponentUpdate 这个方法<b>用来判断是否需要调用 render 方法重新描绘 dom</b>，因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中<b>写出更优化的 dom diff 算法，可以极大的提高性能</b>。</li>
</ul>
<blockquote>
<h3 id="应该在-React-组件的何处发起-ajax-请求"><a href="#应该在-React-组件的何处发起-ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 ajax 请求"></a><font color=pink ><b>应该在 React 组件的何处发起 ajax 请求</b></font></h3></blockquote>
<ul>
<li>在 react 组件中，<b>应该在 componentDidMount 中发网络请求，这个方法会在组件第一次挂载时执行，在组件的生命周期中仅会执行一次</b>。最重要的是，你不能保证组件挂载之前 ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用，<b>在 componentDidMount 中发网络请求将保证这有一个组件可以更新了</b>。</li>
</ul>
<blockquote>
<h3 id="描述事件在-React-中的处理方式，-在-react-中如何处理事件-？"><a href="#描述事件在-React-中的处理方式，-在-react-中如何处理事件-？" class="headerlink" title="描述事件在 React 中的处理方式，(在 react 中如何处理事件)？"></a><font color=pink ><b>描述事件在 React 中的处理方式，(在 react 中如何处理事件)？</b></font></h3></blockquote>
<ul>
<li><p><b>为了解决浏览器的兼容性问题，SyntheticEvent 实例将被传递给事件处理函数</b>。SyntheticEvent 是 react 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation()和 preventDefault()。</p>
</li>
<li><p><b>react 实际上并不将事件附加到子节点本身，react 使用单个事件侦听器侦听顶层所有事件，这对性能有好处，也意味着 react 在更新 dom 时不需要跟踪事件监听器</b>。</p>
</li>
</ul>
<blockquote>
<h3 id="React-组件的划分业务组件技术组件？"><a href="#React-组件的划分业务组件技术组件？" class="headerlink" title="React 组件的划分业务组件技术组件？"></a><font color=pink ><b>React 组件的划分业务组件技术组件？</b></font></h3></blockquote>
<ul>
<li><p>根据组件的职责通常把组件分为<b>UI 组件</b>和<b>容器组件</b>。</p>
</li>
<li><p><b>UI 组件</b>负责 UI 的呈现，<b>容器组件</b>负责管理数据和逻辑。</p>
</li>
<li><p>两者通过<b>React-Redux</b>提供<b>connect</b>方法联系起来。</p>
</li>
</ul>
<blockquote>
<h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同？"></a><font color=pink ><b>展示组件(Presentational component)和容器组件(Container component)之间有何不同？</b></font></h3></blockquote>
<ul>
<li><p><b>展示组件</b>关心<b>组件看起来是什么</b>，展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只会关心 UI 状态而不是数据的状态。</p>
</li>
<li><p><b>容器组件</b>关心<b>组件是如何运作的</b>，容器组件会为展示组件或者其他容器组件提供数据和行为，他们会调用 Flux actions,并将其作为回调提供给展示组件，容器组件经常是有状态的，因为他们是(其它组件的)数据源。</p>
</li>
</ul>
<blockquote>
<h3 id="描述-Flux-与-MVC？"><a href="#描述-Flux-与-MVC？" class="headerlink" title="描述 Flux 与 MVC？"></a><font color=pink ><b>描述 Flux 与 MVC？</b></font></h3></blockquote>
<ul>
<li><p><b>传统的 MVC 模式在分离数据(Model)、UI(View)和逻辑(Controller)方面工作得很好</b>，但是 MVC 架构经常遇到两个主要问题：</p>
<ol>
<li><b>数据流不够清晰</b>：跨视图发生的级联更新常常会导致混乱的事件网络，难于调试</li>
<li><b>缺乏数据完整性</b>：模型数据可以在任何地方发生突变，从而在整个 UI 中产生不可预测的结果</li>
</ol>
</li>
<li><p>使用<b>Flux 模式</b>的复杂用户界面</p>
<ol>
<li><b>不再遭受级联更新</b></li>
<li><b>任何给定的 react 组件都能够根据 store 提供的数据重建其状态</b></li>
<li><b>Flux 模式还通过限制对共享数据的直接访问来加强数据完整性</b></li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="简述-Flux-思想？"><a href="#简述-Flux-思想？" class="headerlink" title="简述 Flux 思想？"></a><font color=pink ><b>简述 Flux 思想？</b></font></h3></blockquote>
<ul>
<li><p>Flux 的最大特点，就是<b>数据的”单向流动”</b></p>
<ol>
<li>用户访问 view</li>
<li>view 发出用户的 action</li>
<li>dispatch 收到 action，要求 store 进行相应的更新</li>
<li>store 更新后，发出一个”change”事件</li>
<li>view 收到”change”事件，更新页面</li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="什么是高阶组件-Higher-Order-Component-？"><a href="#什么是高阶组件-Higher-Order-Component-？" class="headerlink" title="什么是高阶组件(Higher Order Component)？"></a><font color=pink ><b>什么是高阶组件(Higher Order Component)？</b></font></h3></blockquote>
<ul>
<li><b>高阶组件是一个以组件为参数并返回一个新组件的函数</b>。最常见的可能是 Redux 的<b>connect 函数，connect 接收一个 function 作为参数，返回值表示当前组件中可以使用到的 redux 里面的数据</b>。除了简单分享工具库，<b>HOC 最好的方式是共享 React 组件之间的行为</b>，如果你发现在不同的地方写了大量代码来做同一件事时，就应考虑将代码重构为<b>可重用的 HOC</b>。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为<b>纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为</b>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const EnhancedComponent=higherOrderComponent(WrappedComponent);</span></pre></td></tr></table></figure>

<ul>
<li><p><b>HOC 可用于以下许多用例</b>：</p>
<ol>
<li><p>代码重用、逻辑和引导抽象</p>
</li>
<li><p>渲染劫持</p>
</li>
<li><p>state 抽象和操作</p>
</li>
<li><p>props 处理</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="了解-redux-么，说一下-redux-吧？"><a href="#了解-redux-么，说一下-redux-吧？" class="headerlink" title="了解 redux 么，说一下 redux 吧？"></a><font color=pink ><b>了解 redux 么，说一下 redux 吧？</b></font></h3></blockquote>
<ul>
<li><p><b>redux</b> 是一个应用数据流框架，主要解决了组件间状态共享的问题，原理是集中式管理，可以让数据更可控，react 中所有数据处理都在 redux 中进行，三个核心方法，action、store 和 reducer。</p>
</li>
<li><p><b>在 redux 中遵循的原则</b>：</p>
<ol>
<li><p>一个项目只能有一颗数据树。</p>
</li>
<li><p>所有的数据改变都需要在 reducer 中进行。</p>
</li>
<li><p>所有的 action 都是简单的对象。</p>
</li>
<li><p>store 用来存储数据</p>
</li>
</ol>
</li>
<li><p><b>redux 工作流程</b>是：view 调用 store 的 dispatch 接收 action 传入的 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据。</p>
</li>
<li><p><b>Flux</b> 也是用来进行数据操作的，有四个组成部分，action、dispatch、view 和 store。</p>
</li>
<li><p><b>Flux 工作流程</b>是：view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。</p>
</li>
<li><p>Redux 和 Flux 很像，主要<b>区别</b>在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatch 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store、redux 把 store 和 dispatcher 合并，结构更加清晰简单。</p>
</li>
<li><p><b>新增 state，对状态的管理更加明确，通过 redux 流程更加规范，减少手动编码量，提高了编码效率</b>，同时缺点是<b>当数据更新时，有时候组件不需要，但也要重新绘制</b>，有些影响效率，一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们。</p>
</li>
</ul>
<blockquote>
<h3 id="redux-有什么缺点？"><a href="#redux-有什么缺点？" class="headerlink" title="redux 有什么缺点？"></a><font color=pink ><b>redux 有什么缺点？</b></font></h3></blockquote>
<ol>
<li>一个<b>组件所需要的数据，必须由父组件传过来</b>，而不能像 flux 中直接从 store 中取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</li>
</ol>
<blockquote>
<h3 id="React-中的-StrictMode-严格模式-是什么？"><a href="#React-中的-StrictMode-严格模式-是什么？" class="headerlink" title="React 中的 StrictMode(严格模式)是什么？"></a><font color=pink ><b>React 中的 StrictMode(严格模式)是什么？</b></font></h3></blockquote>
<ul>
<li><p>react 的 <b>StrictMode </b>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<StrictMode/>包装一组组件，并且可以帮咱们以下<b>检查</b>：</p>
<ol>
<li><b>验证内部组件是否遵循某些推荐做法</b>，如果没有，会在控制台给出警告</li>
<li><b>验证是否使用的已经废弃的方法</b>，如果有，会在控制台给出警告</li>
<li><b>通过识别潜在的风险预防一些副作用</b></li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="什么是-prop-drilling，如何避免？"><a href="#什么是-prop-drilling，如何避免？" class="headerlink" title="什么是 prop drilling，如何避免？"></a><font color=pink ><b>什么是 prop drilling，如何避免？</b></font></h3></blockquote>
<ul>
<li><p>在构建 react 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据，最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这就叫<b> prop drilling</b>。</p>
</li>
<li><p>prop drilling 的主要<b>缺点</b>是原本不需要数据的组件变得不必要的复杂，并且难以维护。</p>
</li>
<li><p>为了<b>避免</b> prop drilling，一种常用的方法是使用 <b>React Context</b>，通过定义提供数据的 Provider 组件，并允许嵌套的组件通过 Consumer 组件或 useContext Hook 使用上下文数据。<b>通过 Provider 组件可以把 store 也就是整个 redux 和实例绑定</b>。</p>
</li>
</ul>
<blockquote>
<h3 id="什么是-React-Context？"><a href="#什么是-React-Context？" class="headerlink" title="什么是 React Context？"></a><font color=pink ><b>什么是 React Context？</b></font></h3></blockquote>
<ul>
<li><b>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性</b>。</li>
</ul>
<blockquote>
<h3 id="如何避免组件的重新渲染？"><a href="#如何避免组件的重新渲染？" class="headerlink" title="如何避免组件的重新渲染？"></a><font color=pink ><b>如何避免组件的重新渲染？</b></font></h3></blockquote>
<ul>
<li><p>React 中最常见的问题之一是组件不必要的重新渲染，React 提供了两个方法，非常有用：</p>
<ol>
<li><b>React.memo()</b>：这可以防止不必要地重新渲染<b>函数组件</b></li>
<li><b>PureComponent</b>：这可以防止不必要地重新渲染<b>类组件</b></li>
</ol>
</li>
<li><p>这两种方法<b>都依赖于对传递组件的 props 的浅比较，如果 props 没有改变，那么组件将不会重新渲染</b>，虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p>
</li>
<li><p>通过使用 <b>React Profiler</b>，可以在使用这些方法前后<b>对性能进行测量，从而确保通过进行给定的更改来实际改进性能</b></p>
</li>
</ul>
<blockquote>
<h3 id="什么是-React-Fiber？"><a href="#什么是-React-Fiber？" class="headerlink" title="什么是 React Fiber？"></a><font color=pink ><b>什么是 React Fiber？</b></font></h3></blockquote>
<ul>
<li><p>Fiber 是 React16 中<b>新的协调引擎或重新实现核心算法</b>，它的主要目标是<b>支持虚拟 DOM 的增量渲染</b>。</p>
</li>
<li><p>React Fiber 的<b>目标</b>是增强其在动画、布局和手势等领域的适用性,并为不同类型的更新分配优先级，以及新的并发原语。它的<b>主要特性</b>是增量渲染：能够将渲染工作分割成块，并将其分散到多个帧中。</p>
</li>
</ul>
<blockquote>
<h3 id="在-React-中使用构造函数和-getInitialState-有什么区别？"><a href="#在-React-中使用构造函数和-getInitialState-有什么区别？" class="headerlink" title="在 React 中使用构造函数和 getInitialState 有什么区别？"></a><font color=pink ><b>在 React 中使用构造函数和 getInitialState 有什么区别？</b></font></h3></blockquote>
<ul>
<li>构造函数和 getInitialState 之间的区别就是 ES6 和 ES5 本身的区别，在使用 ES6 类时，应该在构造函数中初始化 state，并在使用 React.createClass 时定义 getInitialState 方法。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    constructor(props)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        super(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        this.state=&#123;/*initial state*/&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const MyComponent==React.createClass(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">getInitialState</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">return</span> &#123;/*initial state*/&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="如何有条件地向-React-组件添加属性？"><a href="#如何有条件地向-React-组件添加属性？" class="headerlink" title="如何有条件地向 React 组件添加属性？"></a><font color=pink ><b>如何有条件地向 React 组件添加属性？</b></font></h3></blockquote>
<ul>
<li>对于某些属性 react 非常聪明，如果传递给它的值是虚值，可以省略该属性，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const InputComponent=React.createClass(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    render:<span class="function"><span class="title">function</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        const required=<span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        const disabled=<span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> disabled=&#123;disabled&#125; required=&#123;required&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> required /&gt;</span></pre></td></tr></table></figure>

<ul>
<li>另一种可能的方法是：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const condition = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const component=(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;div</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     value=<span class="string">"foo"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     &#123;...(condition&amp;&amp;&#123;disabled：<span class="literal">true</span>&#125;)&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<blockquote>
<h3 id="createElement和cloneElement有什么区别？"><a href="#createElement和cloneElement有什么区别？" class="headerlink" title="createElement和cloneElement有什么区别？"></a><font color=pink ><b>createElement和cloneElement有什么区别？</b></font></h3></blockquote>
<ul>
<li><p><b>React.createElement()</b>：JSX语法就是用React.createElement()来构建react元素的，<b>它接收三个参数</b>:</p>
<ol>
<li>第一个参数可以是一个标签名，如div、span或者react组件;</li>
<li>第二个参数为传入的属性;</li>
<li>第三个以及之后的参数，皆为组件的子组件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">React.createElement(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">type</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [props],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    [...children]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>React.cloneElement()与React.createElement()相似，<b>不同</b>的是它传入的<b>第一个参数是一个react元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换</b></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    element,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [props],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    [...children]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<h3 id="React项目用过什么脚手架？"><a href="#React项目用过什么脚手架？" class="headerlink" title="React项目用过什么脚手架？"></a><font color=pink ><b>React项目用过什么脚手架？</b></font></h3></blockquote>
<ul>
<li>craet-react-app、Yeoman等</li>
</ul>
<blockquote>
<h3 id="没想好题目-自定义属性-？"><a href="#没想好题目-自定义属性-？" class="headerlink" title="没想好题目..自定义属性.？"></a><font color=pink ><b>没想好题目..自定义属性.？</b></font></h3></blockquote>
<ul>
<li>当应用程序在开发者模式下运行时，<b>react将自动检查咱们在组件设置的所由于性能影响而禁用它</b>。有props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它，强制的props用isRequired定义的。</li>
</ul>
<p>e.g: 一组预定义的prop类型:<br>    React.PropTypes.string<br>    React.PropTypes.number<br>    React.PropTypes.func<br>    React.PropTypes.node<br>    React.PropTypes.bool<br>例如，我们为用户组件定义了如下的propTypes</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    import ProTypes from <span class="string">'prop-types'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Class User extends React.Component&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            &lt;h1&gt;Welcome,&#123;this.props.name&#125;&lt;/h1&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &lt;h2&gt;Age,&#123;this.props.age&#125;&lt;/h2&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">User.propTypes=&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    name:PropTypes.string.isRequired,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    age:PropTypes.number.isRequired</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Wayxuan</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="/http:/yoursite.com/2020/01/03/React%E9%9D%A2%E8%AF%95%E9%A2%98/">http://yoursite.com/2020/01/03/React%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">仙女璇</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/12/23/Node-Cheerio%E4%B8%8EMangoDB/"><span>Node.js-Cheerio篇</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Wayxuan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>